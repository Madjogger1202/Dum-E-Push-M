//   ___                             ___              ___                   _              __  __  //
//  |   \   _  _    _ __     ___    | __|    ___     | _ \  _  _     ___   | |_      ___  |  \/  | //
//  | |) | | +| |  | '  \   |___|   | _|    |___|    |  _/ | +| |   (_-<   | ' \    |___| | |\/| | //
//  |___/   \_,_|  |_|_|_|  _____   |___|   _____   _|_|_   \_,_|   /__/_  |_||_|   _____ |_|__|_| //
//_|"""""|_|"""""|_|"""""|_|     |_|"""""|_|     |_| """ |_|"""""|_|"""""|_|"""""|_|     |_|"""""| //
//"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-'"`-0-0-' //
/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                              \_/                                                //
//                                             (* *)                                               //
//                                            __)#(__                                              //
//                                           ( )...( )(_)                                          //
//                                           || |_| ||//                                           //
//                                         ==() | | ()/                                            //
//                                            _(___)_                                              //
//                                            [-]   [-]                           by @madjogger    //
/////////////////////////////////////////////////////////////////////////////////////////////////////
/*
================================================================================
Project: Dum-E-Push-M ESP32 Telegram-Controlled 4-Servo Manipulator
================================================================================

PURPOSE
- Control 4 hobby servos (e.g., SG90) from a Telegram bot via inline buttons
- Keep secrets (WiFi SSID/PASS, bot token, user whitelist) OUT of git
- Provide a clean, readable, open-source structure

FILES & SECRETS (DON'T COMMIT SECRETS)
- tools/gen_secrets.py     : pre-build script that generates include/generated_secrets.h
- .secrets.json (optional) : local secrets (gitignored) or use ENV vars (WIFI_SSID/WIFI_PASS/BOT_TOKEN/ALLOWED_IDS)
- include/generated_secrets.h (generated) : defines WIFI_SSID, WIFI_PASS, BOT_TOKEN,
                                            ALLOWED_USERS_COUNT, ALLOWED_ID_n, ALLOWED_USERS_LIST, CHAT_ID,
                                            and creates:
                                              static const long long ALLOWED_IDS[ALLOWED_USERS_COUNT] = { ALLOWED_USERS_LIST };

- platformio.ini           : must have
    extra_scripts = pre:tools/gen_secrets.py
    build_flags   = -include include/generated_secrets.h

QUICK START (LOCAL BUILD)
1) Put secrets in ENV or .secrets.json (gitignored):
   {
     "wifi_ssid": "YourAP",
     "wifi_pass": "YourPass",
     "bot_token": "123456:ABC-DEF",
     "allowed_ids": [111111111, 222222222]
   }
2) Ensure .gitignore has:
     /include/generated_secrets.h
     /.secrets.json
3) Build with PlatformIO. The script writes include/generated_secrets.h.
   If missing values, build fails via #error.
4) Flash. First ID in allowed_ids becomes CHAT_ID (admin/default chat).

NOTES
- Telegram IDs can be large/negative (groups). We use 64-bit in generated macros/array.
- For production, consider Wi-Fi provisioning + NVS encryption.

DEPENDENCIES
- ESP32 Arduino core
- ESP32_ISR_Servo
- FastBot2
================================================================================
*/

#include <Arduino.h>
#include <WiFi.h>
#include "ESP32_ISR_Servo.h"
#include <FastBot2.h>
#include "generated_secrets.h"   // Generated by tools/gen_secrets.py

// ---------- Compile-time guards for generated macros ----------
#ifndef WIFI_SSID
  #error "WIFI_SSID is missing. Ensure include/generated_secrets.h is generated and included."
#endif
#ifndef WIFI_PASS
  #error "WIFI_PASS is missing. Ensure include/generated_secrets.h is generated and included."
#endif
#ifndef BOT_TOKEN
  #error "BOT_TOKEN is missing. Ensure include/generated_secrets.h is generated and included."
#endif
#ifndef ALLOWED_USERS_COUNT
  #error "ALLOWED_USERS_COUNT is missing. Ensure include/generated_secrets.h is generated and included."
#endif
#ifndef CHAT_ID
  #error "CHAT_ID is missing. Ensure include/generated_secrets.h defines CHAT_ID (first allowed ID)."
#endif
#ifndef ALLOWED_USERS_LIST
  #error "ALLOWED_USERS_LIST is missing. Update generator to emit ALLOWED_USERS_LIST."
#endif

// ----------------- Telegram bot instance -----------------
FastBot2 bot;

// ----------------- Whitelist (64-bit) -------------------
// IMPORTANT: Do NOT redefine ALLOWED_IDS here.
// It is already defined in generated_secrets.h as:
//   static const long long ALLOWED_IDS[ALLOWED_USERS_COUNT] = { ALLOWED_USERS_LIST };
// If you need legacy names, map them by macros (no extra storage):
#define allowedUsers     ALLOWED_IDS
#define allowedUserCount ALLOWED_USERS_COUNT

// ----------------- Servo wiring/config ------------------
#define NUM_SERVOS 4
static const int servoPins[NUM_SERVOS] = { 18, 19, 21, 22 }; // adjust to your wiring

// SG90 pulse range (adjust if needed)
#define MIN_MICROS 800
#define MAX_MICROS 2450

// ESP32 ISR timer index [0..3]
#define USE_ESP32_TIMER_NO 3

// ----------------- Global state -------------------------
int servoIndices[NUM_SERVOS];     // Handles returned by ESP32_ISR_Servo
int currentPositions[NUM_SERVOS]; // Current angles [0..180]

// ----------------- Predefined poses (degrees) -----------
// Fill with experimentally tuned angles for joints 0..3.
static const int defaultPose[NUM_SERVOS]       = { 90, 90, 90, 90 };
static const int fullyExtendedPose[NUM_SERVOS] = { 90, 90, 90, 90 };
static const int forwardUpPose[NUM_SERVOS]     = { 90, 90, 90, 90 };
static const int forwardDownPose[NUM_SERVOS]   = { 90, 90, 90, 90 };

// ============================================================================
// Helpers
// ============================================================================

/**
 * @brief Check if a Telegram user/chat ID is in the whitelist.
 * @param userId 64-bit Telegram user/chat ID.
 * @return true if whitelisted.
 */
bool isAllowedUser(long long userId) {
  for (size_t i = 0; i < (size_t)allowedUserCount; ++i) {
    if (allowedUsers[i] == userId) return true;
  }
  return false;
}

/**
 * @brief Initialize ISR-based servo control, attach servos to pins,
 *        and set them to a known start angle (90°).
 * Prints diagnostic info to Serial.
 */
void setupServos() {
  ESP32_ISR_Servos.useTimer(USE_ESP32_TIMER_NO);

  for (int i = 0; i < NUM_SERVOS; i++) {
    servoIndices[i] = ESP32_ISR_Servos.setupServo(servoPins[i], MIN_MICROS, MAX_MICROS);
    if (servoIndices[i] != -1) {
      Serial.printf("Servo %d attached to pin %d\n", i, servoPins[i]);
      currentPositions[i] = 90;
      ESP32_ISR_Servos.setPosition(servoIndices[i], currentPositions[i]);
    } else {
      Serial.printf("ERROR: Failed to attach servo %d on pin %d\n", i, servoPins[i]);
    }
  }
}

/**
 * @brief Set an absolute angle for a single servo [0..180].
 * @param servoNum index [0..NUM_SERVOS-1]
 * @param angle target angle [0..180]
 */
void setSingleServo(int servoNum, int angle) {
  if (servoNum < 0 || servoNum >= NUM_SERVOS) return;

  angle = constrain(angle, 0, 180);
  if (servoIndices[servoNum] >= 0) {
    ESP32_ISR_Servos.setPosition(servoIndices[servoNum], angle);
    currentPositions[servoNum] = angle;
  }
}

/**
 * @brief Incrementally rotate a single servo by a given number of degrees.
 *        The final angle is clamped to [0..180].
 * @param servoNum index [0..NUM_SERVOS-1]
 * @param degreesToRotate step in degrees (positive magnitude)
 * @param direction +1 to increase angle, -1 to decrease angle
 */
void rotateServo(int servoNum, int degreesToRotate, int direction) {
  if (servoNum < 0 || servoNum >= NUM_SERVOS) return;
  int currentAngle = currentPositions[servoNum];
  int targetAngle  = currentAngle + (degreesToRotate * direction);
  int finalAngle   = constrain(targetAngle, 0, 180);

  Serial.printf("Servo %d: %d -> %d\n", servoNum, currentAngle, finalAngle);
  setSingleServo(servoNum, finalAngle);
}

/**
 * @brief Move all servos smoothly to a target pose simultaneously.
 *        Linear interpolation + fixed per-step delay.
 * @param targetPose int[NUM_SERVOS] desired angles for all servos
 * @param stepDelayMs delay between steps in milliseconds (controls speed)
 * @param maxAngleStep maximum angle delta per step for the servo with the largest movement
 */
void moveToPose(const int targetPose[], int stepDelayMs, int maxAngleStep) {
  int maxDelta = 0;
  for (int i = 0; i < NUM_SERVOS; i++) {
    int d = abs(targetPose[i] - currentPositions[i]);
    if (d > maxDelta) maxDelta = d;
  }
  if (maxDelta == 0) return;

  int steps = (maxDelta + maxAngleStep - 1) / maxAngleStep; // ceil division

  int startPositions[NUM_SERVOS];
  for (int i = 0; i < NUM_SERVOS; i++) startPositions[i] = currentPositions[i];

  for (int step = 1; step <= steps; step++) {
    for (int i = 0; i < NUM_SERVOS; i++) {
      long mapped = map(step, 0, steps, startPositions[i], targetPose[i]); // map() returns long
      setSingleServo(i, (int)mapped);
    }
    delay(stepDelayMs);
  }

  for (int i = 0; i < NUM_SERVOS; i++) setSingleServo(i, targetPose[i]);
}

// ============================================================================
// Telegram update handler
// ============================================================================

/**
 * @brief FastBot2 update handler for inline button queries.
 * Buttons:
 *   - rotate_left / rotate_right: joint 0 ±5°
 *   - +1/-1, +2/-2, +3/-3      : joints 1..3 ±5°
 *   - pos                      : report current angles
 */
void onUpdate(fb::Update& u) {
  if (!u.isQuery()) return;

  long long userId = (long long)u.query().from().id();
  if (!isAllowedUser(userId)) {
    Serial.printf("Access denied for user ID %lld\n", userId);
    bot.answerCallbackQuery(u.query().id(), "Access denied.");
    return;
  }

  Serial.println("NEW QUERY");
  Serial.println(u.query().data());
  bot.answerCallbackQuery(u.query().id(), "OK");

  switch (u.query().data().hash()) {
    case "rotate_left"_h:  rotateServo(0, 5, +1); break;
    case "rotate_right"_h: rotateServo(0, 5, -1); break;
    case "+1"_h:           rotateServo(1, 5, +1); break;
    case "-1"_h:           rotateServo(1, 5, -1); break;
    case "+2"_h:           rotateServo(2, 5, +1); break;
    case "-2"_h:           rotateServo(2, 5, -1); break;
    case "+3"_h:           rotateServo(3, 5, +1); break;
    case "-3"_h:           rotateServo(3, 5, -1); break;

    case "pos"_h: {
      char buf[128];
      snprintf(buf, sizeof(buf),
               "Current angles:\n0: %d\n1: %d\n2: %d\n3: %d",
               currentPositions[0], currentPositions[1],
               currentPositions[2], currentPositions[3]);
      fb::Message msg(buf, u.query().from().id());
      bot.sendMessage(msg);
      break;
    }
  }
}

// ============================================================================
// Arduino entry points
// ============================================================================

void setup() {
  Serial.begin(115200);
  delay(300);

  Serial.println("--- Manipulator init ---");
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  while (WiFi.status() != WL_CONNECTED) {
    delay(400);
    Serial.print(".");
  }
  Serial.printf("\nWiFi connected, IP: %s\n", WiFi.localIP().toString().c_str());

  setupServos();

  bot.attachUpdate(onUpdate);
  bot.setToken(BOT_TOKEN);
  bot.setPollMode(fb::Poll::Long, 60000);

  fb::Message msg("Send inline menu", CHAT_ID);
  fb::InlineMenu menu(
      "➕;➕;➕\n"
      "➖;➖;➖\n"
      "Left;Right;\n"
      "Current angles;Video",
      "+1;+2;+3;-1;-2;-3;rotate_left;rotate_right;pos;http://217.73.119.112:5353/"
  );
  msg.setInlineMenu(menu);
  bot.sendMessage(msg);

  Serial.println("\nHoming to default pose...");
  moveToPose(defaultPose, /*stepDelayMs=*/20, /*maxAngleStep=*/1);
  Serial.println("Manipulator is ready.\n");
}

void loop() {
  bot.tick();
}
